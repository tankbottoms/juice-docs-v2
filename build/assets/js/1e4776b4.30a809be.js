"use strict";(self.webpackChunkjuice_docs_v_2=self.webpackChunkjuice_docs_v_2||[]).push([[66059],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>d});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=a,f=p["".concat(u,".").concat(d)]||p[d]||m[d]||i;return n?r.createElement(f,o(o({ref:t},s),{},{components:n})):r.createElement(f,o({ref:t},s))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(67294),a=n(86010);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(i,o),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>d});var r=n(87462),a=n(67294),i=n(86010),o=n(72389),l=n(67392),u=n(7094),c=n(12466);const s="tabList__CuJ",m="tabItem_LNqP";function p(e){var t,n;const{lazy:o,block:p,defaultValue:d,values:f,groupId:b,className:h}=e,k=a.Children.map(e.children,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=f?f:k.map((e=>{let{props:{value:t,label:n,attributes:r}}=e;return{value:t,label:n,attributes:r}})),v=(0,l.l)(g,((e,t)=>e.value===t.value));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const y=null===d?d:null!=(t=null!=d?d:null==(n=k.find((e=>e.props.default)))?void 0:n.props.value)?t:k[0].props.value;if(null!==y&&!g.some((e=>e.value===y)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+g.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:_,setTabGroupChoices:N}=(0,u.U)(),[w,I]=(0,a.useState)(y),T=[],{blockElementScrollPositionUntilNextRender:O}=(0,c.o5)();if(null!=b){const e=_[b];null!=e&&e!==w&&g.some((t=>t.value===e))&&I(e)}const j=e=>{const t=e.currentTarget,n=T.indexOf(t),r=g[n].value;r!==w&&(O(t),I(r),null!=b&&N(b,String(r)))},C=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var r;const t=T.indexOf(e.currentTarget)+1;n=null!=(r=T[t])?r:T[0];break}case"ArrowLeft":{var a;const t=T.indexOf(e.currentTarget)-1;n=null!=(a=T[t])?a:T[T.length-1];break}}null==(t=n)||t.focus()};return a.createElement("div",{className:(0,i.Z)("tabs-container",s)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":p},h)},g.map((e=>{let{value:t,label:n,attributes:o}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:w===t?0:-1,"aria-selected":w===t,key:t,ref:e=>T.push(e),onKeyDown:C,onFocus:j,onClick:j},o,{className:(0,i.Z)("tabs__item",m,null==o?void 0:o.className,{"tabs__item--active":w===t})}),null!=n?n:t)}))),o?(0,a.cloneElement)(k.filter((e=>e.props.value===w))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},k.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==w})))))}function d(e){const t=(0,o.Z)();return a.createElement(p,(0,r.Z)({key:String(t)},e))}},21161:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>u,default:()=>d,frontMatter:()=>l,metadata:()=>c,toc:()=>m});var r=n(87462),a=(n(67294),n(3905)),i=n(65488),o=n(85162);const l={},u="_overflowDuring",c={unversionedId:"dev/api/contracts/jbsingletokenpaymentterminalstore/read/-_overflowduring",id:"dev/api/contracts/jbsingletokenpaymentterminalstore/read/-_overflowduring",title:"_overflowDuring",description:"Contract: JBSingleTokenPaymentTerminalStore\u200b\u200c",source:"@site/docs/dev/api/contracts/jbsingletokenpaymentterminalstore/read/-_overflowduring.md",sourceDirName:"dev/api/contracts/jbsingletokenpaymentterminalstore/read",slug:"/dev/api/contracts/jbsingletokenpaymentterminalstore/read/-_overflowduring",permalink:"/dev/api/contracts/jbsingletokenpaymentterminalstore/read/-_overflowduring",draft:!1,editUrl:"https://github.com/jbx-protocol/juice-docs-v2/blob/main/docs/dev/api/contracts/jbsingletokenpaymentterminalstore/read/-_overflowduring.md",tags:[],version:"current",frontMatter:{},sidebar:"dev",previous:{title:"_currentTotalOverflowOf",permalink:"/dev/api/contracts/jbsingletokenpaymentterminalstore/read/-_currenttotaloverflowof"},next:{title:"_reclaimableOverflowDuring",permalink:"/dev/api/contracts/jbsingletokenpaymentterminalstore/read/-_reclaimableoverflowduring"}},s={},m=[{value:"Definition",id:"definition",level:4},{value:"Body",id:"body",level:4}],p={toc:m};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"_overflowduring"},"_overflowDuring"),(0,a.kt)("p",null,"Contract: ",(0,a.kt)("a",{parentName:"p",href:"/dev/api/contracts/jbsingletokenpaymentterminalstore/"},(0,a.kt)("inlineCode",{parentName:"a"},"JBSingleTokenPaymentTerminalStore")),"\u200b\u200c"),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"Step by step",label:"Step by step",mdxType:"TabItem"},(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Gets the amount that is overflowing when measured from the specified funding cycle.")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.")),(0,a.kt)("h4",{id:"definition"},"Definition"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"function _overflowDuring(\n  IJBSingleTokenPaymentTerminal _terminal,\n  uint256 _projectId,\n  JBFundingCycle memory _fundingCycle,\n  uint256 _balanceCurrency\n) private view returns (uint256) { ... }\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Arguments:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_terminal")," is the terminal for which the overflow is being calculated."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_projectId")," is the ID of the project to get overflow for."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_fundingCycle")," is the ID of the funding cycle to base the overflow on."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_balanceCurrency")," is the currency that the stored balance is expected to be in terms of."))),(0,a.kt)("li",{parentName:"ul"},"The view function is private to this contract."),(0,a.kt)("li",{parentName:"ul"},"The view function does not alter state on the blockchain."),(0,a.kt)("li",{parentName:"ul"},"The function returns the overflow of funds, as a fixed point number with the same amount of decimals as the specified terminal.")),(0,a.kt)("h4",{id:"body"},"Body"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Get a reference to the current balance of the project."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"// Get the current balance of the project.\nuint256 _balanceOf = balanceOf[_terminal][_projectId];\n")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("em",{parentName:"p"},"Internal references:")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/dev/api/contracts/jbsingletokenpaymentterminalstore/properties/balanceof"},(0,a.kt)("inlineCode",{parentName:"a"},"balanceOf"))))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"If the project has no balance, there can't be any overflow."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"// If there's no balance, there's no overflow.\nif (_balanceOf == 0) return 0;\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Get a reference to the current distribution limit of the project, along with the currency the limit is in terms of."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"// Get a reference to the distribution limit during the funding cycle.\n(uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(\n  directory.controllerOf(_projectId)\n).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("em",{parentName:"p"},"External references:")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/dev/api/contracts/jbdirectory/properties/controllerof"},(0,a.kt)("inlineCode",{parentName:"a"},"controllerOf"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/dev/api/contracts/or-controllers/jbcontroller/read/distributionlimitof"},(0,a.kt)("inlineCode",{parentName:"a"},"distributionLimitOf"))))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Get a reference to the amount of the funding cycle's target that can still be distributed. This is the difference between its distribution limit and what has already been distributed during this funding cycle."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"// Get a reference to the amount still distributable during the funding cycle.\nuint256 _distributionLimitRemaining = _distributionLimit -\n  usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("em",{parentName:"p"},"Internal references:")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/dev/api/contracts/jbsingletokenpaymentterminalstore/properties/useddistributionlimitof"},(0,a.kt)("inlineCode",{parentName:"a"},"usedDistributionLimitOf"))))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Convert the distribution remaining into the balance's currency using the appropriate price feed. The distribution remaining and balance fixed point numbers should already be using the same number of decimals."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"// Convert the _distributionRemaining to be in terms of the provided currency.\nif (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)\n  _distributionLimitRemaining = PRBMath.mulDiv(\n    _distributionLimitRemaining,\n    10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.\n    prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n  );\n")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("em",{parentName:"p"},"Library references:")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/hifi-finance/prb-math/blob/main/contracts/PRBMath.sol"},(0,a.kt)("inlineCode",{parentName:"a"},"PRBMath")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},".mulDiv(...)"))))),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("em",{parentName:"p"},"Internal references:")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/dev/api/contracts/jbsingletokenpaymentterminalstore/properties/-_max_fixed_point_fidelity"},(0,a.kt)("inlineCode",{parentName:"a"},"_MAX_FIXED_POINT_FIDELITY"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/dev/api/contracts/jbsingletokenpaymentterminalstore/properties/prices"},(0,a.kt)("inlineCode",{parentName:"a"},"prices")))),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("em",{parentName:"p"},"External references:")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/dev/api/contracts/jbprices/read/pricefor"},(0,a.kt)("inlineCode",{parentName:"a"},"priceFor"))))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"If the current balance of the project is at most the target remaining, there is no overflow. Otherwise the difference between the project's current balance and the remaining distribution limit is the overflow."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"// Overflow is the balance of this project minus the amount that can still be distributed.\nreturn _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n"))))),(0,a.kt)(o.Z,{value:"Code",label:"Code",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"/**\n  @notice\n  Gets the amount that is overflowing when measured from the specified funding cycle.\n\n  @dev\n  This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.\n\n  @param _terminal The terminal for which the overflow is being calculated.\n  @param _projectId The ID of the project to get overflow for.\n  @param _fundingCycle The ID of the funding cycle to base the overflow on.\n  @param _balanceCurrency The currency that the stored balance is expected to be in terms of.\n\n  @return overflow The overflow of funds, as a fixed point number with the same amount of decimals as the specified terminal.\n*/\nfunction _overflowDuring(\n  IJBSingleTokenPaymentTerminal _terminal,\n  uint256 _projectId,\n  JBFundingCycle memory _fundingCycle,\n  uint256 _balanceCurrency\n) private view returns (uint256) {\n  // Get the current balance of the project.\n  uint256 _balanceOf = balanceOf[_terminal][_projectId];\n\n  // If there's no balance, there's no overflow.\n  if (_balanceOf == 0) return 0;\n\n  // Get a reference to the distribution limit during the funding cycle.\n  (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = directory\n    .controllerOf(_projectId)\n    .distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n\n  // Get a reference to the amount still distributable during the funding cycle.\n  uint256 _distributionLimitRemaining = _distributionLimit -\n    usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n\n  // Convert the _distributionRemaining to be in terms of the provided currency.\n  if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)\n    _distributionLimitRemaining = PRBMath.mulDiv(\n      _distributionLimitRemaining,\n      10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.\n      prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n    );\n\n  // Overflow is the balance of this project minus the amount that can still be distributed.\n  return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n}\n"))),(0,a.kt)(o.Z,{value:"Bug bounty",label:"Bug bounty",mdxType:"TabItem"},(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Category"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"),(0,a.kt)("th",{parentName:"tr",align:null},"Reward"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Optimization")),(0,a.kt)("td",{parentName:"tr",align:null},"Help make this operation more efficient."),(0,a.kt)("td",{parentName:"tr",align:null},"0.5ETH")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Low severity")),(0,a.kt)("td",{parentName:"tr",align:null},"Identify a vulnerability in this operation that could lead to an inconvenience for a user of the protocol or for a protocol developer."),(0,a.kt)("td",{parentName:"tr",align:null},"1ETH")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"High severity")),(0,a.kt)("td",{parentName:"tr",align:null},"Identify a vulnerability in this operation that could lead to data corruption or loss of funds."),(0,a.kt)("td",{parentName:"tr",align:null},"5+ETH")))))))}d.isMDXComponent=!0}}]);