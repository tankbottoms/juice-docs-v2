"use strict";(self.webpackChunkjuice_docs_v_2=self.webpackChunkjuice_docs_v_2||[]).push([[75301],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),m=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=m(n),k=r,u=d["".concat(s,".").concat(k)]||d[k]||c[k]||o;return n?a.createElement(u,i(i({ref:t},p),{},{components:n})):a.createElement(u,i({ref:t},p))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var m=2;m<o;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),r=n(86010);const o="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,i),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>k});var a=n(87462),r=n(67294),o=n(86010),i=n(72389),l=n(67392),s=n(7094),m=n(12466);const p="tabList__CuJ",c="tabItem_LNqP";function d(e){var t,n;const{lazy:i,block:d,defaultValue:k,values:u,groupId:f,className:h}=e,b=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),N=null!=u?u:b.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),v=(0,l.l)(N,((e,t)=>e.value===t.value));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const y=null===k?k:null!=(t=null!=k?k:null==(n=b.find((e=>e.props.default)))?void 0:n.props.value)?t:b[0].props.value;if(null!==y&&!N.some((e=>e.value===y)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+N.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:g,setTabGroupChoices:_}=(0,s.U)(),[T,C]=(0,r.useState)(y),j=[],{blockElementScrollPositionUntilNextRender:E}=(0,m.o5)();if(null!=f){const e=g[f];null!=e&&e!==T&&N.some((t=>t.value===e))&&C(e)}const I=e=>{const t=e.currentTarget,n=j.indexOf(t),a=N[n].value;a!==T&&(E(t),C(a),null!=f&&_(f,String(a)))},w=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var a;const t=j.indexOf(e.currentTarget)+1;n=null!=(a=j[t])?a:j[0];break}case"ArrowLeft":{var r;const t=j.indexOf(e.currentTarget)-1;n=null!=(r=j[t])?r:j[j.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",p)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":d},h)},N.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>j.push(e),onKeyDown:w,onFocus:I,onClick:I},i,{className:(0,o.Z)("tabs__item",c,null==i?void 0:i.className,{"tabs__item--active":T===t})}),null!=n?n:t)}))),i?(0,r.cloneElement)(b.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},b.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function k(e){const t=(0,i.Z)();return r.createElement(d,(0,a.Z)({key:String(t)},e))}},85402:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>k,frontMatter:()=>l,metadata:()=>m,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),o=n(65488),i=n(85162);const l={},s="_pay",m={unversionedId:"dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/write/-_pay",id:"dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/write/-_pay",title:"_pay",description:"Contract: JBPayoutRedemptionPaymentTerminal\u200b\u200c",source:"@site/docs/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/write/-_pay.md",sourceDirName:"dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/write",slug:"/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/write/-_pay",permalink:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/write/-_pay",draft:!1,editUrl:"https://github.com/jbx-protocol/juice-docs-v2/blob/main/docs/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/write/-_pay.md",tags:[],version:"current",frontMatter:{},sidebar:"dev",previous:{title:"supportsInterface",permalink:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/read/supportsinterface"},next:{title:"addToBalanceOf",permalink:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/write/addtobalanceof"}},p={},c=[{value:"Definition",id:"definition",level:4},{value:"Body",id:"body",level:4}],d={toc:c};function k(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"_pay"},"_pay"),(0,r.kt)("p",null,"Contract: ",(0,r.kt)("a",{parentName:"p",href:"/zh/dev/api/contracts/or-payment-terminals/or-abstract/jbpayoutredemptionpaymentterminal/"},(0,r.kt)("inlineCode",{parentName:"a"},"JBPayoutRedemptionPaymentTerminal")),"\u200b\u200c"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"Step by step",label:"Step by step",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Allows a v1 project token holder to pay into this terminal to get commensurate about of its v2 token.")),(0,r.kt)("h4",{id:"definition"},"Definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"function _pay(\n  uint256 _amount,\n  address _payer,\n  uint256 _projectId,\n  address _beneficiary,\n  uint256 _minReturnedTokens,\n  bool _preferClaimedTokens,\n  string memory _memo,\n  bytes memory _metadata\n) private returns (uint256 beneficiaryTokenCount) { ... }\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Arguments:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_projectId")," is the ID of the v2 project to pay towards."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_amount")," is te amount of v1 project tokens being paid, as a fixed point number with the same amount of decimals as this terminal."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_token")," is the token being paid. This terminal ignores this property since it only manages v1 tokens preset by the project being paid."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_beneficiary")," is the address to mint v2 project tokens for."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_minReturnedTokens")," is the minimum number of v2 project tokens expected in return, as a fixed point number with 18 decimals."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_preferClaimedTokens")," is a flag indicating whether the request prefers to mint v2 project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_memo")," is memo to pass along to the emitted event. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_metadata")," are bytes to send along to the data source, delegate, and emitted event, if provided. This terminal ignores this property because there's no data source."))),(0,r.kt)("li",{parentName:"ul"},"The function is private to this contract."),(0,r.kt)("li",{parentName:"ul"},"The function returns the number of v2 tokens minted for the beneficiary, as a fixed point number with 18 decimals.")),(0,r.kt)("h4",{id:"body"},"Body"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get a reference to the v1 project ID that has been set for the v2 project being paid."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Get the v1 project for the v2 project being paid.\nuint256 _v1ProjectId = v1ProjectIdOf[_projectId];\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Internal references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/properties/v1projectidof"},(0,r.kt)("inlineCode",{parentName:"a"},"v1ProjectIdOf"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Make sure there is a v1 project ID set."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Make sure the v1 project has been set.\nif (_v1ProjectId == 0) revert V1_PROJECT_NOT_SET();\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get a reference to the v1 project's ERC20 token, if one has been issued."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Get a reference to the v1 project's ERC20 tokens.\nITickets _v1Token = ticketBooth.ticketsOf(_v1ProjectId);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Internal references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/properties/ticketbooth"},(0,r.kt)("inlineCode",{parentName:"a"},"ticketBooth")))),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/jbx-protocol/juice-contracts-v1/blob/a91b55e8d264267c338b089aa9a45b29fd8e8f13/contracts/interfaces/ITicketBooth.sol#L69"},(0,r.kt)("inlineCode",{parentName:"a"},"ticketsOf")))))),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},'The following scoped block is a bit of a hack to prevent a "Stack too deep" error. Define a few variables outside of the scope that\'ll be set within the scope but later referenced again outside.'),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Define variables that will be needed outside the scoped section below.\n// Keep a reference to the amount of v2 tokens to mint from the message sender's v1 ERC20 balance.\nuint256 _tokensToMintFromERC20s;\n\n// Scoped section prevents stack too deep. `_unclaimedBalance` and `_erc20Balance` only used within scope.\n{ ... }\n")),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get a reference to the amount of unclaimed v1 tokens the message sender has in the contract."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Get a reference to the migrator's unclaimed balance.\nuint256 _unclaimedBalance = ticketBooth.stakedBalanceOf(msg.sender, _v1ProjectId);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Internal references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/properties/ticketbooth"},(0,r.kt)("inlineCode",{parentName:"a"},"ticketBooth")))),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/jbx-protocol/juice-contracts-v1/blob/a91b55e8d264267c338b089aa9a45b29fd8e8f13/contracts/interfaces/ITicketBooth.sol#L84"},(0,r.kt)("inlineCode",{parentName:"a"},"stakedBalanceOf"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get a reference to the amount of ERC20 v1 tokens the message sender has. If there's no ERC20, the balance is 0. "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Get a reference to the migrator's ERC20 balance.\nuint256 _erc20Balance = _v1Token == ITickets(address(0)) ? 0 : _v1Token.balanceOf(msg.sender);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-balanceOf-address-"},(0,r.kt)("inlineCode",{parentName:"a"},"balanceOf"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Make sure the message sender has enough of a balance between their v1 unclaimed tokens and v1 ERC20 tokens to cover the amount being exchanged for v2 tokens. "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// There must be enough v1 tokens to migrate.\nif (_amount > _erc20Balance + _unclaimedBalance) revert INSUFFICIENT_FUNDS();\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Calculate how many v1 project ERC20s will be exchanged for v2 tokens. If a project owner has both unclaimed tokens and ERC20 tokens, adhere to the claimed token preference to determine whether to prioritize exchanging one over the other. "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// If there's no ERC20 balance, theres no tokens to mint as a result of the ERC20 balance.\nif (_erc20Balance == 0)\n  _tokensToMintFromERC20s = 0;\n  // If prefer claimed tokens, exchange ERC20 tokens before exchanging unclaimed tokens.\nelse if (_preferClaimedTokens)\n  _tokensToMintFromERC20s = _erc20Balance < _amount ? _erc20Balance : _amount;\n  // Otherwise, exchange unclaimed tokens before ERC20 tokens.\nelse _tokensToMintFromERC20s = _unclaimedBalance < _amount ? _amount - _unclaimedBalance : 0;\n"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get a reference to the amount of v2 tokens to mint from the message sender's v1 unclaimed token balance, which is the total amount to exchange minus the amount of ERC20's to exchange."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// The amount of unclaimed tokens to migrate.\nuint256 _tokensToMintFromUnclaimedBalance = _amount - _tokensToMintFromERC20s;\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"If needed, transfer ERC20's from the message sender to this contract. This requires an allowance for this contract to transfer tokens on the message sender's behalf."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Transfer v1 ERC20 tokens to this terminal from the msg sender if needed.\nif (_tokensToMintFromERC20s != 0)\n  IERC20(_v1Token).transferFrom(msg.sender, address(this), _tokensToMintFromERC20s);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-transferFrom-address-address-uint256-"},(0,r.kt)("inlineCode",{parentName:"a"},"transferFrom"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"If needed, transfer unclaimed tokens from the message sender to this contract. This requires operator permissions for this contract to transfer unclaimed tokens on the message sender's behalf."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Transfer v1 unclaimed tokens to this terminal from the msg sender if needed.\nif (_tokensToMintFromUnclaimedBalance != 0)\n  ticketBooth.transfer(\n    msg.sender,\n    _v1ProjectId,\n    _tokensToMintFromUnclaimedBalance,\n    address(this)\n  );\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Internal references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/properties/ticketbooth"},(0,r.kt)("inlineCode",{parentName:"a"},"ticketBooth")))),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/jbx-protocol/juice-contracts-v1/blob/a91b55e8d264267c338b089aa9a45b29fd8e8f13/contracts/interfaces/ITicketBooth.sol#L145"},(0,r.kt)("inlineCode",{parentName:"a"},"transfer"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Mint v2 tokens for the specified beneficiary. "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Mint the v2 tokens for the beneficary.\nbeneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n  _projectId,\n  _amount,\n  _beneficiary,\n  '',\n  _preferClaimedTokens,\n  false\n);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Internal references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/properties/directory"},(0,r.kt)("inlineCode",{parentName:"a"},"directory")))),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/jbdirectory/properties/controllerof"},(0,r.kt)("inlineCode",{parentName:"a"},"controllerOf"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-controllers/jbcontroller/write/minttokensof"},(0,r.kt)("inlineCode",{parentName:"a"},"mintTokensOf"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Make sure the beneficiary is getting the same amount of v2 tokens as v1 tokens were exchanged, and that the amount is at least as much as expected."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Make sure the token amount is the same as the v1 token amount and is at least what is expected.\nif (beneficiaryTokenCount != _amount || beneficiaryTokenCount < _minReturnedTokens)\n  revert UNEXPECTED_AMOUNT();\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Emit a ",(0,r.kt)("inlineCode",{parentName:"p"},"Pay")," event with the relevant parameters."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"emit Pay(\n  _projectId,\n  msg.sender,\n  _beneficiary,\n  _amount,\n  beneficiaryTokenCount,\n  _memo,\n  msg.sender\n);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Event references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/events/pay"},(0,r.kt)("inlineCode",{parentName:"a"},"Pay"))))))),(0,r.kt)(i.Z,{value:"Code",label:"Code",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"/** \n  @notice \n  Allows a v1 project token holder to pay into this terminal to get commensurate about of its v2 token.\n\n  @param _projectId The ID of the v2 project to pay towards.\n  @param _amount The amount of v1 project tokens being paid, as a fixed point number with the same amount of decimals as this terminal.\n  @param _beneficiary The address to mint tokens for.\n  @param _minReturnedTokens The minimum number of v2 project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.\n  @param _preferClaimedTokens A flag indicating whether the request prefers to mint v2 project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.\n  @param _memo A memo to pass along to the emitted event. \n\n  @return beneficiaryTokenCount The number of v2 tokens minted for the beneficiary, as a fixed point number with 18 decimals.\n*/\nfunction _pay(\n  uint256 _projectId,\n  uint256 _amount,\n  address _beneficiary,\n  uint256 _minReturnedTokens,\n  bool _preferClaimedTokens,\n  string calldata _memo\n) internal returns (uint256 beneficiaryTokenCount) {\n  // Get the v1 project for the v2 project being paid.\n  uint256 _v1ProjectId = v1ProjectIdOf[_projectId];\n\n  // Make sure the v1 project has been set.\n  if (_v1ProjectId == 0) revert V1_PROJECT_NOT_SET();\n\n  // Get a reference to the v1 project's ERC20 tokens.\n  ITickets _v1Token = ticketBooth.ticketsOf(_v1ProjectId);\n\n  // Define variables that will be needed outside the scoped section below.\n  // Keep a reference to the amount of v2 tokens to mint from an ERC20 balance.\n  uint256 _tokensToMintFromERC20s;\n\n  {\n    // Get a reference to the migrator's unclaimed balance.\n    uint256 _unclaimedBalance = ticketBooth.stakedBalanceOf(msg.sender, _v1ProjectId);\n\n    // Get a reference to the migrator's ERC20 balance.\n    uint256 _erc20Balance = _v1Token == ITickets(address(0)) ? 0 : _v1Token.balanceOf(msg.sender);\n\n    // There must be enough v1 tokens to migrate.\n    if (_amount > _erc20Balance + _unclaimedBalance) revert INSUFFICIENT_FUNDS();\n\n    // If there's no ERC20 balance, theres no tokens to mint as a result of the ERC20 balance.\n    if (_erc20Balance == 0)\n      _tokensToMintFromERC20s = 0;\n      // If prefer claimed tokens, exchange ERC20 tokens before exchanging unclaimed tokens.\n    else if (_preferClaimedTokens)\n      _tokensToMintFromERC20s = _erc20Balance < _amount ? _erc20Balance : _amount;\n      // Otherwise, exchange unclaimed tokens before ERC20 tokens.\n    else _tokensToMintFromERC20s = _unclaimedBalance < _amount ? _amount - _unclaimedBalance : 0;\n  }\n\n  // The amount of unclaimed tokens to migrate.\n  uint256 _tokensToMintFromUnclaimedBalance = _amount - _tokensToMintFromERC20s;\n\n  // Transfer v1 ERC20 tokens to this terminal from the msg sender if needed.\n  if (_tokensToMintFromERC20s != 0)\n    IERC20(_v1Token).transferFrom(msg.sender, address(this), _tokensToMintFromERC20s);\n\n  // Transfer v1 unclaimed tokens to this terminal from the msg sender if needed.\n  if (_tokensToMintFromUnclaimedBalance != 0)\n    ticketBooth.transfer(\n      msg.sender,\n      _v1ProjectId,\n      _tokensToMintFromUnclaimedBalance,\n      address(this)\n    );\n\n  // Mint the v2 tokens for the beneficary.\n  beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n    _projectId,\n    _amount,\n    _beneficiary,\n    '',\n    _preferClaimedTokens,\n    false\n  );\n\n  // Make sure the token amount is the same as the v1 token amount and is at least what is expected.\n  if (beneficiaryTokenCount != _amount || beneficiaryTokenCount < _minReturnedTokens)\n    revert UNEXPECTED_AMOUNT();\n\n  emit Pay(\n    _projectId,\n    msg.sender,\n    _beneficiary,\n    _amount,\n    beneficiaryTokenCount,\n    _memo,\n    msg.sender\n  );\n}\n"))),(0,r.kt)(i.Z,{value:"Errors",label:"Errors",mdxType:"TabItem"},(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"String"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("inlineCode",{parentName:"strong"},"V1_PROJECT_NOT_SET"))),(0,r.kt)("td",{parentName:"tr",align:null},"Thrown if the v2 project being paid hasn't set its v1 project yet.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("inlineCode",{parentName:"strong"},"INSUFFICIENT_FUNDS"))),(0,r.kt)("td",{parentName:"tr",align:null},"Thrown if the message sender doesn't have a sufficient balance of v1 tokens to pay.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("inlineCode",{parentName:"strong"},"UNEXPECTED_AMOUNT"))),(0,r.kt)("td",{parentName:"tr",align:null},"Thrown if the amount of v2 tokens minted for the beneficiary isn't expected."))))),(0,r.kt)(i.Z,{value:"Events",label:"Events",mdxType:"TabItem"},(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Data"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/zh/dev/api/contracts/or-payment-terminals/jbv1tokenpaymentterminal/events/pay"},(0,r.kt)("strong",{parentName:"a"},(0,r.kt)("inlineCode",{parentName:"strong"},"Pay")))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("code",null,"uint256 indexed projectId")),(0,r.kt)("li",null,(0,r.kt)("code",null,"address payer")),(0,r.kt)("li",null,(0,r.kt)("code",null,"address beneficiary")),(0,r.kt)("li",null,(0,r.kt)("code",null,"uint256 amount")),(0,r.kt)("li",null,(0,r.kt)("code",null,"uint256 beneficiaryTokenCount")),(0,r.kt)("li",null,(0,r.kt)("code",null,"string memo")),(0,r.kt)("li",null,(0,r.kt)("code",null,"address caller")))))))),(0,r.kt)(i.Z,{value:"Bug bounty",label:"Bug bounty",mdxType:"TabItem"},(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Category"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Reward"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Optimization")),(0,r.kt)("td",{parentName:"tr",align:null},"Help make this operation more efficient."),(0,r.kt)("td",{parentName:"tr",align:null},"0.5ETH")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Low severity")),(0,r.kt)("td",{parentName:"tr",align:null},"Identify a vulnerability in this operation that could lead to an inconvenience for a user of the protocol or for a protocol developer."),(0,r.kt)("td",{parentName:"tr",align:null},"1ETH")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"High severity")),(0,r.kt)("td",{parentName:"tr",align:null},"Identify a vulnerability in this operation that could lead to data corruption or loss of funds."),(0,r.kt)("td",{parentName:"tr",align:null},"5+ETH")))))))}k.isMDXComponent=!0}}]);