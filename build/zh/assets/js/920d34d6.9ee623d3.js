"use strict";(self.webpackChunkjuice_docs_v_2=self.webpackChunkjuice_docs_v_2||[]).push([[4985],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,f=c["".concat(s,".").concat(m)]||c[m]||d[m]||r;return n?a.createElement(f,l(l({ref:t},u),{},{components:n})):a.createElement(f,l({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(67294),i=n(86010);const r="tabItem_Ymn6";function l(e){let{children:t,hidden:n,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,l),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(87462),i=n(67294),r=n(86010),l=n(72389),o=n(67392),s=n(7094),p=n(12466);const u="tabList__CuJ",d="tabItem_LNqP";function c(e){var t,n;const{lazy:l,block:c,defaultValue:m,values:f,groupId:h,className:k}=e,b=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),_=null!=f?f:b.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),y=(0,o.l)(_,((e,t)=>e.value===t.value));if(y.length>0)throw new Error('Docusaurus error: Duplicate values "'+y.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const v=null===m?m:null!=(t=null!=m?m:null==(n=b.find((e=>e.props.default)))?void 0:n.props.value)?t:b[0].props.value;if(null!==v&&!_.some((e=>e.value===v)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+_.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:N,setTabGroupChoices:T}=(0,s.U)(),[g,w]=(0,i.useState)(v),C=[],{blockElementScrollPositionUntilNextRender:E}=(0,p.o5)();if(null!=h){const e=N[h];null!=e&&e!==g&&_.some((t=>t.value===e))&&w(e)}const j=e=>{const t=e.currentTarget,n=C.indexOf(t),a=_[n].value;a!==g&&(E(t),w(a),null!=h&&T(h,String(a)))},A=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var a;const t=C.indexOf(e.currentTarget)+1;n=null!=(a=C[t])?a:C[0];break}case"ArrowLeft":{var i;const t=C.indexOf(e.currentTarget)-1;n=null!=(i=C[t])?i:C[C.length-1];break}}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",u)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":c},k)},_.map((e=>{let{value:t,label:n,attributes:l}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:g===t?0:-1,"aria-selected":g===t,key:t,ref:e=>C.push(e),onKeyDown:A,onFocus:j,onClick:j},l,{className:(0,r.Z)("tabs__item",d,null==l?void 0:l.className,{"tabs__item--active":g===t})}),null!=n?n:t)}))),l?(0,i.cloneElement)(b.filter((e=>e.props.value===g))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},b.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==g})))))}function m(e){const t=(0,l.Z)();return i.createElement(c,(0,a.Z)({key:String(t)},e))}},41913:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),r=n(65488),l=n(85162);const o={},s="_payTo",p={unversionedId:"dev/api/contracts/or-utilities/jbetherc20splitspayer/write/-_payto",id:"dev/api/contracts/or-utilities/jbetherc20splitspayer/write/-_payto",title:"_payTo",description:"Contract: JBETHERC20SplitsPayer",source:"@site/docs/dev/api/contracts/or-utilities/jbetherc20splitspayer/write/-_payto.md",sourceDirName:"dev/api/contracts/or-utilities/jbetherc20splitspayer/write",slug:"/dev/api/contracts/or-utilities/jbetherc20splitspayer/write/-_payto",permalink:"/zh/dev/api/contracts/or-utilities/jbetherc20splitspayer/write/-_payto",draft:!1,editUrl:"https://github.com/jbx-protocol/juice-docs-v2/blob/main/docs/dev/api/contracts/or-utilities/jbetherc20splitspayer/write/-_payto.md",tags:[],version:"current",frontMatter:{},sidebar:"dev",previous:{title:"supportsInterface",permalink:"/zh/dev/api/contracts/or-utilities/jbetherc20splitspayer/read/supportsinterface"},next:{title:"_payToSplits",permalink:"/zh/dev/api/contracts/or-utilities/jbetherc20splitspayer/write/-_paytosplits"}},u={},d=[{value:"Definition",id:"definition",level:4},{value:"Body",id:"body",level:4}],c={toc:d};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"_payto"},"_payTo"),(0,i.kt)("p",null,"Contract: ",(0,i.kt)("a",{parentName:"p",href:"/zh/dev/api/contracts/or-utilities/jbetherc20splitspayer/"},(0,i.kt)("inlineCode",{parentName:"a"},"JBETHERC20SplitsPayer"))),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"Step by step",label:"Step by step",mdxType:"TabItem"},(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Split an amount between all splits.")),(0,i.kt)("h4",{id:"definition"},"Definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function _payTo(\n  JBSplit[] memory _splits,\n  address _token,\n  uint256 _amount,\n  uint256 _decimals,\n  address _defaultBeneficiary\n) internal virtual returns (uint256 leftoverAmount) { ... }\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Arguments:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_splits")," are the splits."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_token")," is the token the amonut being split is in."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_amount")," is the amount of tokens being split, as a fixed point number. If the ",(0,i.kt)("inlineCode",{parentName:"li"},"_token")," is ETH, this is ignored and msg.value is used in its place."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_decimals")," is the number of decimals in the ",(0,i.kt)("inlineCode",{parentName:"li"},"_amount")," fixed point number. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_defaultBeneficiary")," is the address that will benefit from any non-specified beneficiaries in splits."))),(0,i.kt)("li",{parentName:"ul"},"The function is private to this contract."),(0,i.kt)("li",{parentName:"ul"},"The function returns the amount leftover after all splits were paid.")),(0,i.kt)("h4",{id:"body"},"Body"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"At first the leftover amount is the full amount. This will be decremented as the splits are iterated on."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"// Set the leftover amount to the initial balance.\nleftoverAmount = _amount;\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Distribute to each split. f there's at least some funds to send to the split, determine where they should go. If the split has an ",(0,i.kt)("inlineCode",{parentName:"p"},"allocator")," set, send the funds to its ",(0,i.kt)("inlineCode",{parentName:"p"},"allocate")," function, passing along any relevant params. Otherwise if a ",(0,i.kt)("inlineCode",{parentName:"p"},"projectId")," is specified in the split, send the payout to that project. Add to the project's balance if the split has a preference to do so, otherwise send a payment and use the split's ",(0,i.kt)("inlineCode",{parentName:"p"},"beneficiary")," as the address that should receive the project's tokens in return, or use the message sender if a beneficiary wasn't provided. If no project was specified, send the funds directly to the ",(0,i.kt)("inlineCode",{parentName:"p"},"beneficiary")," address from the split if one was provided. If the split didn't give any routing information, send the amount to the messag sender. Decrement the ",(0,i.kt)("inlineCode",{parentName:"p"},"leftoverAmount")," once the split is settled. Emit a ",(0,i.kt)("inlineCode",{parentName:"p"},"DistributeToSplit")," event with the relevant parameters."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"// Settle between all splits.\nfor (uint256 i = 0; i < _splits.length; i++) {\n  // Get a reference to the split being iterated on.\n  JBSplit memory _split = _splits[i];\n\n  // The amount to send towards the split.\n  uint256 _splitAmount = PRBMath.mulDiv(\n    _amount,\n    _split.percent,\n    JBConstants.SPLITS_TOTAL_PERCENT\n  );\n\n  if (_splitAmount > 0) {\n    // Transfer tokens to the split.\n    // If there's an allocator set, transfer to its `allocate` function.\n    if (_split.allocator != IJBSplitAllocator(address(0))) {\n      // Create the data to send to the allocator.\n      JBSplitAllocationData memory _data = JBSplitAllocationData(\n        _token,\n        _splitAmount,\n        _decimals,\n        defaultProjectId,\n        0,\n        _split\n      );\n\n      // Approve the `_amount` of tokens for the split allocator to transfer tokens from this contract.\n      if (_token != JBTokens.ETH)\n        IERC20(_token).approve(address(_split.allocator), _splitAmount);\n\n      // If the token is ETH, send it in msg.value.\n      uint256 _payableValue = _token == JBTokens.ETH ? _splitAmount : 0;\n\n      // Trigger the allocator's `allocate` function.\n      _split.allocator.allocate{value: _payableValue}(_data);\n\n      // Otherwise, if a project is specified, make a payment to it.\n    } else if (_split.projectId != 0) {\n      if (_split.preferAddToBalance)\n        _addToBalanceOf(\n          _split.projectId,\n          _token,\n          _splitAmount,\n          _decimals,\n          defaultMemo,\n          defaultMetadata\n        );\n      else\n        _pay(\n          _split.projectId,\n          _token,\n          _splitAmount,\n          _decimals,\n          _split.beneficiary != address(0) ? _split.beneficiary : _defaultBeneficiary,\n          0,\n          _split.preferClaimed,\n          defaultMemo,\n          defaultMetadata\n        );\n    } else {\n      // Transfer the ETH.\n      if (_token == JBTokens.ETH)\n        Address.sendValue(\n          // Get a reference to the address receiving the tokens. If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the `_defaultBeneficiary`.\n          _split.beneficiary != address(0) ? _split.beneficiary : payable(_defaultBeneficiary),\n          _splitAmount\n        );\n        // Or, transfer the ERC20.\n      else {\n        IERC20(_token).transfer(\n          // Get a reference to the address receiving the tokens. If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the `_defaultBeneficiary`.\n          _split.beneficiary != address(0) ? _split.beneficiary : _defaultBeneficiary,\n          _splitAmount\n        );\n      }\n    }\n\n    // Subtract from the amount to be sent to the beneficiary.\n    leftoverAmount = leftoverAmount - _splitAmount;\n  }\n\n  emit DistributeToSplit(\n    _splitsProjectId,\n    _splitsDomain,\n    _splitsGroup,\n    _split,\n    _splitAmount,\n    _defaultBeneficiary,\n    msg.sender\n  );\n}\n")),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Library references:")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/zh/dev/api/libraries/jbtokens"},(0,i.kt)("inlineCode",{parentName:"a"},"JBTokens")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".ETH")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.openzeppelin.com/contracts/4.x/api/utils#Address"},(0,i.kt)("inlineCode",{parentName:"a"},"Address")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".sendValue(...)"))))),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Internal references:")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-utilities/jbetherc20projectpayer/write/-_pay"},(0,i.kt)("inlineCode",{parentName:"a"},"_pay"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-utilities/jbetherc20projectpayer/write/-_addtobalanceof"},(0,i.kt)("inlineCode",{parentName:"a"},"_addToBalanceOf")))),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"External references:")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-approve-address-uint256-"},(0,i.kt)("inlineCode",{parentName:"a"},"approve"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-transfer-address-uint256-"},(0,i.kt)("inlineCode",{parentName:"a"},"transfer"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/zh/dev/api/interfaces/ijbsplitallocator"},(0,i.kt)("inlineCode",{parentName:"a"},"allocate")))),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Event references:")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/or-utilities/jbetherc20splitspayer/events/distributetosplit"},(0,i.kt)("inlineCode",{parentName:"a"},"DistributeToSplit"))))))),(0,i.kt)(l.Z,{value:"Code",label:"Code",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"/** \n  @notice \n  Split an amount between all splits.\n\n  @param _splits The splits.\n  @param _token The token the amonut being split is in.\n  @param _amount The amount of tokens being split, as a fixed point number. If the `_token` is ETH, this is ignored and msg.value is used in its place.\n  @param _decimals The number of decimals in the `_amount` fixed point number. \n  @param _defaultBeneficiary The address that will benefit from any non-specified beneficiaries in splits.\n\n  @return leftoverAmount The amount leftover after all splits were paid.\n*/\nfunction _payTo(\n  JBSplit[] memory _splits,\n  address _token,\n  uint256 _amount,\n  uint256 _decimals,\n  address _defaultBeneficiary\n) internal virtual returns (uint256 leftoverAmount) {\n  // Set the leftover amount to the initial balance.\n  leftoverAmount = _amount;\n\n  // Settle between all splits.\n  for (uint256 i = 0; i < _splits.length; i++) {\n    // Get a reference to the split being iterated on.\n    JBSplit memory _split = _splits[i];\n\n    // The amount to send towards the split.\n    uint256 _splitAmount = PRBMath.mulDiv(\n      _amount,\n      _split.percent,\n      JBConstants.SPLITS_TOTAL_PERCENT\n    );\n\n    if (_splitAmount > 0) {\n      // Transfer tokens to the split.\n      // If there's an allocator set, transfer to its `allocate` function.\n      if (_split.allocator != IJBSplitAllocator(address(0))) {\n        // Create the data to send to the allocator.\n        JBSplitAllocationData memory _data = JBSplitAllocationData(\n          _token,\n          _splitAmount,\n          _decimals,\n          defaultProjectId,\n          0,\n          _split\n        );\n\n        // Approve the `_amount` of tokens for the split allocator to transfer tokens from this contract.\n        if (_token != JBTokens.ETH)\n          IERC20(_token).approve(address(_split.allocator), _splitAmount);\n\n        // If the token is ETH, send it in msg.value.\n        uint256 _payableValue = _token == JBTokens.ETH ? _splitAmount : 0;\n\n        // Trigger the allocator's `allocate` function.\n        _split.allocator.allocate{value: _payableValue}(_data);\n\n        // Otherwise, if a project is specified, make a payment to it.\n      } else if (_split.projectId != 0) {\n        if (_split.preferAddToBalance)\n          _addToBalanceOf(\n            _split.projectId,\n            _token,\n            _splitAmount,\n            _decimals,\n            defaultMemo,\n            defaultMetadata\n          );\n        else\n          _pay(\n            _split.projectId,\n            _token,\n            _splitAmount,\n            _decimals,\n            _split.beneficiary != address(0) ? _split.beneficiary : _defaultBeneficiary,\n            0,\n            _split.preferClaimed,\n            defaultMemo,\n            defaultMetadata\n          );\n      } else {\n        // Transfer the ETH.\n        if (_token == JBTokens.ETH)\n          Address.sendValue(\n            // Get a reference to the address receiving the tokens. If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the `_defaultBeneficiary`.\n            _split.beneficiary != address(0) ? _split.beneficiary : payable(_defaultBeneficiary),\n            _splitAmount\n          );\n          // Or, transfer the ERC20.\n        else {\n          IERC20(_token).transfer(\n            // Get a reference to the address receiving the tokens. If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the `_defaultBeneficiary`.\n            _split.beneficiary != address(0) ? _split.beneficiary : _defaultBeneficiary,\n            _splitAmount\n          );\n        }\n      }\n\n      // Subtract from the amount to be sent to the beneficiary.\n      leftoverAmount = leftoverAmount - _splitAmount;\n    }\n\n    emit DistributeToSplit(\n      _splitsProjectId,\n      _splitsDomain,\n      _splitsGroup,\n      _split,\n      _splitAmount,\n      _defaultBeneficiary,\n      msg.sender\n    );\n  }\n}\n"))),(0,i.kt)(l.Z,{value:"Events",label:"Events",mdxType:"TabItem"},(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Data"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/zh/dev/api/contracts/or-utilities/jbetherc20splitspayer/events/distributetosplit"},(0,i.kt)("strong",{parentName:"a"},(0,i.kt)("inlineCode",{parentName:"strong"},"DistributeToSplit")))),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("ul",null,(0,i.kt)("li",null,(0,i.kt)("code",null,(0,i.kt)("a",{parentName:"td",href:"/zh/dev/api/data-structures/jbsplit"},"JBSplit")," split")),(0,i.kt)("li",null,(0,i.kt)("code",null,"uint256 amount")),(0,i.kt)("li",null,(0,i.kt)("code",null,"address caller")))))))),(0,i.kt)(l.Z,{value:"Bug bounty",label:"Bug bounty",mdxType:"TabItem"},(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Category"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Reward"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Optimization")),(0,i.kt)("td",{parentName:"tr",align:null},"Help make this operation more efficient."),(0,i.kt)("td",{parentName:"tr",align:null},"0.5ETH")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Low severity")),(0,i.kt)("td",{parentName:"tr",align:null},"Identify a vulnerability in this operation that could lead to an inconvenience for a user of the protocol or for a protocol developer."),(0,i.kt)("td",{parentName:"tr",align:null},"1ETH")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"High severity")),(0,i.kt)("td",{parentName:"tr",align:null},"Identify a vulnerability in this operation that could lead to data corruption or loss of funds."),(0,i.kt)("td",{parentName:"tr",align:null},"5+ETH")))))))}m.isMDXComponent=!0}}]);