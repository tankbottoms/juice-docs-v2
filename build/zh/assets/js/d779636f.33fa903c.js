"use strict";(self.webpackChunkjuice_docs_v_2=self.webpackChunkjuice_docs_v_2||[]).push([[69967],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),s=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(m.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=s(n),p=r,h=c["".concat(m,".").concat(p)]||c[p]||d[p]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var m in t)hasOwnProperty.call(t,m)&&(l[m]=t[m]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),r=n(86010);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,o),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>p});var a=n(87462),r=n(67294),i=n(86010),o=n(72389),l=n(67392),m=n(7094),s=n(12466);const u="tabList__CuJ",d="tabItem_LNqP";function c(e){var t,n;const{lazy:o,block:c,defaultValue:p,values:h,groupId:f,className:k}=e,g=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),y=null!=h?h:g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),b=(0,l.l)(y,((e,t)=>e.value===t.value));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const N=null===p?p:null!=(t=null!=p?p:null==(n=g.find((e=>e.props.default)))?void 0:n.props.value)?t:g[0].props.value;if(null!==N&&!y.some((e=>e.value===N)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+N+'" but none of its children has the corresponding value. Available values are: '+y.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:v,setTabGroupChoices:_}=(0,m.U)(),[C,w]=(0,r.useState)(N),T=[],{blockElementScrollPositionUntilNextRender:j}=(0,s.o5)();if(null!=f){const e=v[f];null!=e&&e!==C&&y.some((t=>t.value===e))&&w(e)}const I=e=>{const t=e.currentTarget,n=T.indexOf(t),a=y[n].value;a!==C&&(j(t),w(a),null!=f&&_(f,String(a)))},P=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var a;const t=T.indexOf(e.currentTarget)+1;n=null!=(a=T[t])?a:T[0];break}case"ArrowLeft":{var r;const t=T.indexOf(e.currentTarget)-1;n=null!=(r=T[t])?r:T[T.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,i.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":c},k)},y.map((e=>{let{value:t,label:n,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:e=>T.push(e),onKeyDown:P,onFocus:I,onClick:I},o,{className:(0,i.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":C===t})}),null!=n?n:t)}))),o?(0,r.cloneElement)(g.filter((e=>e.props.value===C))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==C})))))}function p(e){const t=(0,o.Z)();return r.createElement(c,(0,a.Z)({key:String(t)},e))}},57139:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>m,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var a=n(87462),r=(n(67294),n(3905)),i=n(65488),o=n(85162);const l={},m="recordPaymentFrom",s={unversionedId:"dev/api/contracts/jbsingletokenpaymentterminalstore/write/recordpaymentfrom",id:"dev/api/contracts/jbsingletokenpaymentterminalstore/write/recordpaymentfrom",title:"recordPaymentFrom",description:"Contract: JBSingleTokenPaymentTerminalStore\u200b\u200c",source:"@site/docs/dev/api/contracts/jbsingletokenpaymentterminalstore/write/recordpaymentfrom.md",sourceDirName:"dev/api/contracts/jbsingletokenpaymentterminalstore/write",slug:"/dev/api/contracts/jbsingletokenpaymentterminalstore/write/recordpaymentfrom",permalink:"/zh/dev/api/contracts/jbsingletokenpaymentterminalstore/write/recordpaymentfrom",draft:!1,editUrl:"https://github.com/jbx-protocol/juice-docs-v2/blob/main/docs/dev/api/contracts/jbsingletokenpaymentterminalstore/write/recordpaymentfrom.md",tags:[],version:"current",frontMatter:{},sidebar:"dev",previous:{title:"recordMigration",permalink:"/zh/dev/api/contracts/jbsingletokenpaymentterminalstore/write/recordmigration"},next:{title:"recordRedemptionFor",permalink:"/zh/dev/api/contracts/jbsingletokenpaymentterminalstore/write/recordredemptionfor"}},u={},d=[{value:"Definition",id:"definition",level:4},{value:"Body",id:"body",level:4}],c={toc:d};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"recordpaymentfrom"},"recordPaymentFrom"),(0,r.kt)("p",null,"Contract: ",(0,r.kt)("a",{parentName:"p",href:"/zh/dev/api/contracts/jbsingletokenpaymentterminalstore/"},(0,r.kt)("inlineCode",{parentName:"a"},"JBSingleTokenPaymentTerminalStore")),"\u200b\u200c"),(0,r.kt)("p",null,"Interface: ",(0,r.kt)("a",{parentName:"p",href:"/zh/dev/api/interfaces/ijbsingletokenpaymentterminalstore"},(0,r.kt)("inlineCode",{parentName:"a"},"IJBSingleTokenPaymentTerminalStore"))),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"Step by step",label:"Step by step",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Records newly contributed tokens to a project.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"The msg.sender must be an ",(0,r.kt)("a",{parentName:"em",href:"/zh/dev/api/interfaces/ijbpaymentterminal"},(0,r.kt)("inlineCode",{parentName:"a"},"IJBSingleTokenPaymentTerminal")),". The amount specified in the params is in terms of the msg.sender's tokens.")),(0,r.kt)("h4",{id:"definition"},"Definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"function recordPaymentFrom(\n  address _payer,\n  JBTokenAmount calldata _amount,\n  uint256 _projectId,\n  uint256 _baseWeightCurrency,\n  address _beneficiary,\n  string calldata _memo,\n  bytes memory _metadata\n)\n  external\n  override\n  nonReentrant\n  returns (\n    JBFundingCycle memory fundingCycle,\n    uint256 tokenCount,\n    IJBPayDelegate delegate,\n    string memory memo\n  ) { ... }\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Arguments:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_payer")," is the original address that sent the payment to the terminal."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_amount")," is a ",(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/data-structures/jbtokenamount"},(0,r.kt)("inlineCode",{parentName:"a"},"JBTokenAmount"))," data structure specifying the amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_projectId")," is the ID of the project being paid."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_baseWeightCurrency")," is the currency to base token issuance on."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_beneficiary")," is the specified address that should be the beneficiary of anything that results from the payment."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_memo")," is a memo to pass along to the emitted event, and passed along to the funding cycle's data source."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_metadata")," are bytes to send along to the data source, if one is provided."))),(0,r.kt)("li",{parentName:"ul"},"The resulting function overrides a function definition from the ",(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/interfaces/ijbsingletokenpaymentterminalstore"},(0,r.kt)("inlineCode",{parentName:"a"},"JBSingleTokenPaymentTerminalStore"))," interface."),(0,r.kt)("li",{parentName:"ul"},"The function returns:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fundingCycle")," is the project's funding cycle during which payment was made."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tokenCount")," is the number of project tokens that were minted, as a fixed point number with 18 decimals."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"delegate")," is a delegate contract to use for subsequent calls."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"memo")," is a memo that should be passed along to the emitted event.")))),(0,r.kt)("h4",{id:"body"},"Body"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get a reference to the project's current funding cycle that should have its properties used in the subsequent calculations and returned."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Get a reference to the current funding cycle for the project.\nfundingCycle = fundingCycleStore.currentOf(_projectId);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/jbfundingcyclestore/read/currentof"},(0,r.kt)("inlineCode",{parentName:"a"},"currentOf"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Make sure the project has a funding cycle configured. This is done by checking if the project's current funding cycle number is non-zero."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// The project must have a funding cycle configured.\nif (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Make sure the project's funding cycle isn't configured to pause payments."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Must not be paused.\nif (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Library references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/libraries/jbfundingcyclemetadataresolver"},(0,r.kt)("inlineCode",{parentName:"a"},"JBFundingCycleMetadataResolver")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".payPaused(...)")))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create a variable where the weight to use in subsquent calculations will be saved."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\nuint256 _weight;\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"If the project's current funding cycle is configured to use a data source when receiving payments, ask the data source for the parameters that should be used throughout the rest of the function given provided contextual values in a ",(0,r.kt)("a",{parentName:"p",href:"/zh/dev/api/data-structures/jbpayparamsdata"},(0,r.kt)("inlineCode",{parentName:"a"},"JBPayParamsData"))," structure. Otherwise default parameters are used."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// If the funding cycle has configured a data source, use it to derive a weight and memo.\nif (fundingCycle.useDataSourceForPay()) {\n  // Create the params that'll be sent to the data source.\n  JBPayParamsData memory _data = JBPayParamsData(\n    IJBSingleTokenPaymentTerminal(msg.sender),\n    _payer,\n    _amount,\n    _projectId,\n    _beneficiary,\n    fundingCycle.configuration,\n    fundingCycle.weight,\n    fundingCycle.reservedRate(),\n    _memo,\n    _metadata\n  );\n  (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n    _data\n  );\n}\n// Otherwise use the funding cycle's weight\nelse {\n  _weight = fundingCycle.weight;\n  memo = _memo;\n}\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Library references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/libraries/jbfundingcyclemetadataresolver"},(0,r.kt)("inlineCode",{parentName:"a"},"JBFundingCycleMetadataResolver")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".useDataSourceForPay(...)"),"\\"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".dataSource(...)"),"\\"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".reservedRate(...)"))))),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/interfaces/ijbfundingcycledatasource"},(0,r.kt)("inlineCode",{parentName:"a"},"payParams"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"If there is no amount being recorded, there's nothing left to do so the current values can be returned."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// If there's no amount being recorded, there's nothing left to do.\nif (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Add the amount being paid to the stored balance."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Add the amount to the token balance of the project.\nbalanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n  balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n  _amount.value;\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Internal references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/jbsingletokenpaymentterminalstore/properties/balanceof"},(0,r.kt)("inlineCode",{parentName:"a"},"balanceOf"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"If there is no weight, the resulting token count will be 0. There's nothing left to do so the current values can be returned."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// If there's no weight, token count must be 0 so there's nothing left to do.\nif (_weight == 0) return (fundingCycle, 0, delegate, memo);\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Calculate the weight ratio. This allows a project to get paid in a certain token, but issue project tokens relative to a different base currency. The weight ratio will be used to divide the product of the paid amount and the weight to determine the number of tokens that should be distributed. Since the number of distributed tokens should be a fixed point number with 18 decimals, the weight ratio must have the same number of decimals as the amount to cancel it out and leave only the fidelity of the 18 decimal fixed point weight."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Get a reference to the number of decimals in the amount. (prevents stack too deep).\nuint256 _decimals = _amount.decimals;\n\n// If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n// The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.\nuint256 _weightRatio = _amount.currency == _baseWeightCurrency\n  ? 10**_decimals\n  : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"External references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/zh/dev/api/contracts/jbprices/read/pricefor"},(0,r.kt)("inlineCode",{parentName:"a"},"priceFor"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Determine the number of tokens to mint."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"// Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.\ntokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Library references:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/hifi-finance/prb-math/blob/main/contracts/PRBMath.sol"},(0,r.kt)("inlineCode",{parentName:"a"},"PRBMath")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".mulDiv(...)")))))))),(0,r.kt)(o.Z,{value:"Code",label:"Code",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"/**\n  @notice\n  Records newly contributed tokens to a project.\n\n  @dev\n  Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n\n  @dev\n  The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n\n  @param _payer The original address that sent the payment to the terminal.\n  @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n  @param _projectId The ID of the project being paid.\n  @param _baseWeightCurrency The currency to base token issuance on.\n  @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n  @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n  @param _metadata Bytes to send along to the data source, if one is provided.\n\n  @return fundingCycle The project's funding cycle during which payment was made.\n  @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n  @return delegate A delegate contract to use for subsequent calls.\n  @return memo A memo that should be passed along to the emitted event.\n*/\nfunction recordPaymentFrom(\n  address _payer,\n  JBTokenAmount calldata _amount,\n  uint256 _projectId,\n  uint256 _baseWeightCurrency,\n  address _beneficiary,\n  string calldata _memo,\n  bytes memory _metadata\n)\n  external\n  override\n  nonReentrant\n  returns (\n    JBFundingCycle memory fundingCycle,\n    uint256 tokenCount,\n    IJBPayDelegate delegate,\n    string memory memo\n  )\n{\n  // Get a reference to the current funding cycle for the project.\n  fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n  // The project must have a funding cycle configured.\n  if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n  // Must not be paused.\n  if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n  uint256 _weight;\n\n  // If the funding cycle has configured a data source, use it to derive a weight and memo.\n  if (fundingCycle.useDataSourceForPay()) {\n    // Create the params that'll be sent to the data source.\n    JBPayParamsData memory _data = JBPayParamsData(\n      IJBSingleTokenPaymentTerminal(msg.sender),\n      _payer,\n      _amount,\n      _projectId,\n      _beneficiary,\n      fundingCycle.configuration,\n      fundingCycle.weight,\n      fundingCycle.reservedRate(),\n      _memo,\n      _metadata\n    );\n    (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n      _data\n    );\n  }\n  // Otherwise use the funding cycle's weight\n  else {\n    _weight = fundingCycle.weight;\n    memo = _memo;\n  }\n\n  // If there's no amount being recorded, there's nothing left to do.\n  if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n\n  // Add the amount to the token balance of the project.\n  balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n    _amount.value;\n\n  // If there's no weight, token count must be 0 so there's nothing left to do.\n  if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n\n  // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n  uint256 _decimals = _amount.decimals;\n\n  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n  // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.\n  uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n    ? 10**_decimals\n    : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n\n  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.\n  tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n}\n"))),(0,r.kt)(o.Z,{value:"Errors",label:"Errors",mdxType:"TabItem"},(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"String"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("inlineCode",{parentName:"strong"},"INVALID_FUNDING_CYCLE"))),(0,r.kt)("td",{parentName:"tr",align:null},"Thrown if the project doesn't have a funding cycle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("inlineCode",{parentName:"strong"},"FUNDING_CYCLE_PAYMENT_PAUSED"))),(0,r.kt)("td",{parentName:"tr",align:null},"Thrown if the project has configured its current funding cycle to pause payments."))))),(0,r.kt)(o.Z,{value:"Bug bounty",label:"Bug bounty",mdxType:"TabItem"},(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Category"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Reward"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Optimization")),(0,r.kt)("td",{parentName:"tr",align:null},"Help make this operation more efficient."),(0,r.kt)("td",{parentName:"tr",align:null},"0.5ETH")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Low severity")),(0,r.kt)("td",{parentName:"tr",align:null},"Identify a vulnerability in this operation that could lead to an inconvenience for a user of the protocol or for a protocol developer."),(0,r.kt)("td",{parentName:"tr",align:null},"1ETH")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"High severity")),(0,r.kt)("td",{parentName:"tr",align:null},"Identify a vulnerability in this operation that could lead to data corruption or loss of funds."),(0,r.kt)("td",{parentName:"tr",align:null},"5+ETH")))))))}p.isMDXComponent=!0}}]);